<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <title>OrbisMesh - Connections</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>

        /* ====== Reset / Base ====== */
        *{box-sizing:border-box}
        a{color:inherit; text-decoration:none}       

        /* ====== Main Area ====== */

        /* ====== Existing page styles (leicht angepasst) ====== */
        .header {
            display:flex; justify-content:space-between; align-items:stretch; gap:12px;
        }
        .logo-header img, .header img { height:60px; object-fit:contain }
        

        .status-indicator{ display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:8px }
        .status-active{ background:var(--brand) }
        .status-inactive{ background:var(--danger) }
        .stats{ font-size:14px; margin:8px 0 }
        .local-mac{ font-size:14px; color:#999 }

        .count-badge{
            display:inline-block;
            margin-left:.5rem;
            padding:2px 8px;
            border-radius:999px;
            font-size:.9rem;
            line-height:1.4;
            background: var(--bg-3);
            color: var(--muted);
            border:1px solid var(--border);
            vertical-align:middle;
        }

        /* Config styles kept for future reuse on this page */
        .config-controls{ display:flex; flex-direction:column; gap:16px }
        .current-config{ font-size:16px; padding:8px; background:var(--bg); border-radius:4px }
        .channel-selector{ display:flex; align-items:center; gap:12px }
        #channel-select{
            background:var(--bg); color:var(--text); border:1px solid var(--border);
            padding:8px; border-radius:4px;
        }
        #apply-channel{
            background:var(--brand); color:#fff; border:none; padding:8px 16px; border-radius:4px; cursor:pointer;
        }
        #apply-channel:hover{ filter:brightness(.95) }
        #apply-channel:disabled{ background:#666; cursor:not-allowed }
        /* Content bleibt immer an der Position der eingeklappten Rail */

        @media (max-width: 420px){
            .node-grid{ grid-template-columns: 1fr; }
        }
        .node-grid{
            display: grid;
            gap: 12px;
            /* Neu: robustes, mobiles Grid */
            grid-template-columns: repeat(auto-fit, minmax(min(100%, 320px), 1fr));
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            box-sizing: border-box;
        }
        .node-card.inactive{ background:#161616; opacity:.55; color:#666 }
    </style>

    <script>
        function loadMeshConfig(){
            fetch('/api/mesh-config')
                .then(r=>r.json())
                .then(data=>{
                    const select = document.getElementById('channel-select');
                    if(!select) return; // (Auf dieser Seite derzeit nicht eingeblendet)
                    document.getElementById('current-channel').textContent = data.current_channel;
                    document.getElementById('current-frequency').textContent = data.current_frequency;

                    select.innerHTML='';
                    const ch24 = data.available_channels.filter(c=>c<=14);
                    const ch5  = data.available_channels.filter(c=>c>14);

                    if(ch24.length){
                        const g=document.createElement('optgroup'); g.label='2.4 GHz';
                        ch24.forEach(c=>{
                            const o=document.createElement('option');
                            o.value=c; o.textContent=`Channel ${c} (${WIFI_CHANNELS[c]} MHz)`;
                            if(c===data.current_channel) o.selected=true;
                            g.appendChild(o);
                        });
                        select.appendChild(g);
                    }
                    if(ch5.length){
                        const g=document.createElement('optgroup'); g.label='5 GHz';
                        ch5.forEach(c=>{
                            const o=document.createElement('option');
                            o.value=c; o.textContent=`Channel ${c} (${WIFI_CHANNELS[c]} MHz)`;
                            if(c===data.current_channel) o.selected=true;
                            g.appendChild(o);
                        });
                        select.appendChild(g);
                    }
                })
                .catch(()=>{ /* optional status */ });
        }

        function changeChannel(){
            const selected = parseInt(document.getElementById('channel-select').value);
            const current  = parseInt(document.getElementById('current-channel').textContent);
            if(selected===current){ showStatus('Channel is already set to '+selected,'error'); return; }
            if(!confirm(`Change mesh channel to ${selected}? This will restart the system and temporarily disconnect all nodes.`)) return;

            const btn=document.getElementById('apply-channel');
            btn.disabled=true; btn.textContent='Applying...';
            showStatus('Changing channel and rebooting system...','info');

            fetch('/api/mesh-config',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({channel:selected})})
              .then(r=>r.json())
              .then(d=>{
                if(d.success){ showStatus(d.message,'success'); }
                else{ showStatus(d.error || 'Failed to change channel','error'); btn.disabled=false; btn.textContent='Apply Channel';}
              })
              .catch(()=>{ showStatus('Failed to change channel','error'); btn.disabled=false; btn.textContent='Apply Channel';});
        }

        function showStatus(message,type){
            const el=document.getElementById('config-status');
            if(!el) return;
            el.textContent=message;
            el.className=`status-message status-${type}`;
            el.style.display='block';
            if(type!=='error'){ setTimeout(()=>{ el.style.display='none'; },5000); }
        }

        function getDbm(node){
            // Versuche gängige Felder in dieser Reihenfolge
            if (typeof node.signal_dbm === 'number') return node.signal_dbm;
            if (typeof node.rssi_dbm === 'number') return node.rssi_dbm;
            if (typeof node.rssi === 'number') return node.rssi; // falls bereits dBm
            if (typeof node.signal === 'string') {
                const m = node.signal.match(/-?\d+(\.\d+)?/);
                if (m) return parseFloat(m[0]);
            }
            return NaN;
        }
        
        function dbmToPct(dbm){
            if (isNaN(dbm)) return null;
            // Mappe -95 dBm -> 0%, -35 dBm -> 100% (clamped)
            const min = -95, max = -35;
            let q = (dbm - min) / (max - min);
            q = Math.max(0, Math.min(1, q));
            return Math.round(q * 100);
        }
        
        function fmtDbm(dbm){
            if (isNaN(dbm)) return '—';
            // Zeige ganzzahlig; bei Bedarf auf eine Nachkommastelle ändern
            return Math.round(dbm).toString();
        }

        function n(v){ return (typeof v === 'number' && !Number.isNaN(v)) ? v : null; }

        function fmtInt(v){ v = n(v); return (v===null)?'—':Math.round(v).toString(); }

        function fmtMbps(v){ v = n(v); return (v===null)?'—':v.toFixed(0); }
        
        function loadMeshConfig(){ /* ... unverändert ... */ }

        function changeChannel(){ /* ... unverändert ... */ }

        function showStatus(message,type){ /* ... unverändert ... */ }

        function updateData(){
            fetch('/api/wifi')
                .then(r=>r.json())
                .then(data=>{
                // Seitentitel
                document.querySelector('h1').textContent = data.hostname;

                const entries = Object.entries(data.node_status || {});
                const visible = entries.filter(([_, n]) => Number(n.last_seen) <= data.node_timeout).length;

                const grid = document.querySelector('.node-grid');
                grid.innerHTML = '';

                // ---------- LOCAL CARD (immer ganz oben) ----------
                const localMac = data.local?.mac || data.local_mac || '';
                const rawHost  = (data.local && data.local.hostname) ? String(data.local.hostname).trim() : '';
                const hostText = rawHost ? rawHost : 'Waiting for hostname...';
                const isPH     = !rawHost;

                // Batterie-% (0..100) oder null
                let batt = data.local && typeof data.local.battery_pct !== 'undefined'
                ? Number(data.local.battery_pct) : null;
                if (Number.isFinite(batt)) {
                batt = Math.max(0, Math.min(100, batt));
                } else {
                    batt = null;
                }
                const battLabel = (batt===null) ? '—' : `${batt}%`;
                const health = data.health || {};
                const ok = k => health[k] === 'ok';

                grid.insertAdjacentHTML('afterbegin', `
                <div class="node-card local">
                    <!-- Neue Kopfzeile: 'Local Node' in gleicher Schrift/Größe wie Hostname -->
                    <h3 class="host-title">Local Node:</h3>

                    <!-- Hostname-Zeile (ohne Status-Indikator-Punkt) -->
                    <h3 class="host-title ${isPH ? 'placeholder' : ''}">${hostText}</h3>

                    <!-- MAC darunter (kursiv) und mit extra Abstand nach unten -->
                    <div class="node-subtitle mac"><span class="mono">${localMac}</span></div>

                    <!-- Der Counter-Badge bei <h2> entfällt; stattdessen hier -->
                    <div class="stats stats-compact">
                        Visible Nodes: <span class="mono hl-orange">${visible}</span>
                    </div>

                    <!-- Batterieanzeige im selben Stil wie die Signal-Leiste -->
                    <div class="stats">Battery: <span class="mono">${battLabel}</span></div>
                    <div class="signal" title="${batt===null?'':'Battery ' + batt + '%'}">
                    <div class="battery-bar" style="--pct:${batt ?? 0}">
                    <div class="battery-mask"></div>
                    </div>
                    <div class="signal-label">${batt===null?'—':batt + '%'}</div>
                    </div>

                    <!-- Health-Check: drei Punkte -->
                    <div class="stats svc-list">
                    <div class="svc-item">
                        <span class="status-indicator ${ok('ogm-monitor') ? 'status-active' : 'status-inactive'}"></span>
                        ogm-monitor
                    </div>
                    <div class="svc-item">
                        <span class="status-indicator ${ok('alfred') ? 'status-active' : 'status-inactive'}"></span>
                        alfred
                    </div>
                    <div class="svc-item">
                        <span class="status-indicator ${ok('mesh-monitor') ? 'status-active' : 'status-inactive'}"></span>
                        mesh-monitor
                    </div>
                    </div>
                </div>
                `);


                // ---------- REMOTE NODES (danach) ----------
                entries.forEach(([mac, node]) => {
                    const hostname = (node.hostname && String(node.hostname).trim())
                    ? node.hostname : 'Waiting for hostname...';

                    const inactive = Number(node.last_seen) > data.node_timeout;

                    const dbm = getDbm(node);
                    const pct = dbmToPct(dbm);
                    const pctText = (pct===null) ? '—' : (pct + '%');

                    const rx_packets   = node.rx_packets;
                    const rx_drop_misc = node.rx_drop_misc;
                    const tx_packets   = node.tx_packets;
                    const tx_retries   = node.tx_retries;
                    const tx_failed    = node.tx_failed;
                    const tx_bitrate   = node.tx_bitrate_mbps;
                    const rx_bitrate   = node.rx_bitrate_mbps;

                    grid.insertAdjacentHTML('beforeend', `
                    <div class="node-card ${inactive?'inactive':''}">
                        <h3>
                        <span class="status-indicator ${inactive?'status-inactive':'status-active'}"></span>${hostname}
                        </h3>
                        <div class="node-subtitle mac"><span class="mono">${mac}</span></div>

                        <div class="stats">Signal: <span class="mono">${fmtDbm(dbm)}</span> dBm</div>
                        <div class="signal" title="${isNaN(dbm)?'':dbm+' dBm'}">
                        <div class="signal-bar" style="--pct:${pct ?? 0}">
                            <div class="signal-mask"></div>
                        </div>
                        <div class="signal-label">${pctText}</div>
                        </div>

                        <div class="stats stats-compact">Last Seen: ${Number(node.last_seen).toFixed(2)}s ago</div>
                        <div class="stats stats-compact">Batman est.: ${Number(node.throughput).toFixed(1)} Mb/s</div>
                        <div class="stats stats-compact">Next Hop: ${node.nexthop}</div>

                        <div class="stats grid-rt">
                        <div>
                            <div><strong>Local RX</strong></div>
                            <div>Packets: <span class="mono">${fmtInt(rx_packets)}</span></div>
                            <div>Drop misc: <span class="mono">${fmtInt(rx_drop_misc)}</span></div>
                            <div>Bitrate: <span class="mono">${fmtMbps(rx_bitrate)}</span> Mb/s</div>
                        </div>
                        <div>
                            <div><strong>Local TX</strong></div>
                            <div>Packets: <span class="mono">${fmtInt(tx_packets)}</span></div>
                            <div>Retries: <span class="mono">${fmtInt(tx_retries)}</span></div>
                            <div>Failed: <span class="mono">${fmtInt(tx_failed)}</span></div>
                            <div>Bitrate: <span class="mono">${fmtMbps(tx_bitrate)}</span> Mb/s</div>
                        </div>
                        </div>
                    </div>
                    `);
                });

                setTimeout(updateData, 1000);
                })
                .catch(()=> setTimeout(updateData, 1000));
            }

        function syncStatusDotColors(){
            // Hilfsfunktion: erzeugt kurz ein Probe-Element mit der gewünschten Klasse
            const probe = (cls) => {
                const el = document.createElement('span');
                el.className = `status-indicator ${cls}`;
                el.style.position = 'absolute';
                el.style.left = '-9999px';      // außerhalb des Viewports
                el.style.pointerEvents = 'none';
                document.body.appendChild(el);
                const col = getComputedStyle(el).backgroundColor;
                el.remove();
                return col;
            };

            const ok  = probe('status-active');
            const bad = probe('status-inactive');

            if (ok)  document.documentElement.style.setProperty('--status-ok',  ok);
            if (bad) document.documentElement.style.setProperty('--status-bad', bad);
            }

        document.addEventListener('DOMContentLoaded', () => {
            syncStatusDotColors();
            const sb=document.querySelector('.sidebar'); applySidebarState(sb);
            updateData(); /* Mesh Live-Daten */
        });
    </script>
  <link rel="stylesheet" href="{{ url_for('static', filename='app.css') }}">
</head>
<body>
    {% set active = 'connections' %}
    {% include 'sidebar.html' %}
    <!-- ====== Main content ====== -->
    <main class="main">
        <div class="header">
      <div style="display:flex;flex-direction:column;align-items:flex-start;flex:1;">
        <h1 style="margin:0;">{{ hostname }}</h1>
      </div>
    </div>
        <div class="section">
            <h2>Connections</span></h2>
            <div class="node-grid">
                {% for mac, node in node_status.items() %}
                {% set is_inactive = node.last_seen > node_timeout %}
                <div class="node-card{% if is_inactive %} inactive{% endif %}">
                    <div class="stats">Waiting for backend to initialize...</div>
                </div>
                {% endfor %}
            </div>
        </div>

        <!-- Optional: Platzhalter für Status-Meldungen, falls du hier später Aktionen zulässt -->
        <div id="config-status" class="status-message" aria-live="polite"></div>
    </main>
</body>
</html>
